<!DOCTYPE html>
<html lang="en" class="keep-it-100">
<head>





    <link rel="stylesheet" type="text/css" href="/html/css/bulma.min.css" >
    <link rel="stylesheet" type="text/css" href="/html/css/all.min.css" >

    
    <script type="text/javascript" src="/html/js/vue.js"></script>


    <link  href="/html/css/cropper.css" rel="stylesheet">
    <script src="/html/js/cropper.js"></script>


    <style>

        html,body,#app {
          height: 100%;
          margin: 0;
        }

        #app {
          display: flex;
          flex-direction: column;
        }

        header {

          text-align: center;
        }

        main {
          flex: 1;
          display: flex;
          min-height: 0;
        }

        nav {

          width: 20%;
          overflow: auto;
          padding: 1em;
          
        }

        article {
          width: 80%;
          overflow: auto;
          padding: 1em;
        }


        details, .filter-holders {
            border: 1px solid #aaa;
            border-radius: 4px;
            border-bottom-right-radius: 0;
            border-bottom-left-radius: 0;
            padding: .5em .5em 0;

        }

        .filter-holders {
            border-top-right-radius: 0;
            border-top-left-radius: 0;
            border-top: none;
       }

        summary {
            font-weight: bold;
            margin: -.5em -.5em 0;
            padding: .5em;
            cursor: pointer;
        }

        details[open] {
            padding: .5em;
        }

        details[open] summary {
            border-bottom: 1px solid #aaa;
            margin-bottom: .5em;
        }        


        #cropper-container{
            margin-top: 2em;
        }
        #cropper-container img {
          display: block;

          /* This rule is very important, please don't ignore this */
          max-width: 100%;                    
        }



        .list-holder{
            max-height: 50px;
            width: 100%;
            background: whitesmoke;
            border-top-left-radius: 2em;
            border-bottom-left-radius: 2em;
            margin-bottom: 2px;
            display: flex;
              justify-content: center;
              align-items: center;
            cursor: pointer;

        }

        .list-holder:hover{
            background: #ffdf002b;
        }


        .list-holder:hover .initals{
            color: #fcffdd;
        }


        .list-holder img{
            border-radius: 1.5em;
                height: 50px;            
        }
        .list-holder-image-holder{
            flex: 1;
        }
        .list-holder-name-holder{
            flex: 5;
            overflow: hidden;
        }

        .list-holder-name-holder span{
            font-size: 2em;
            white-space: nowrap;
        }

        .initals{
            text-align: center;
            font-size: 2em;
            background: lightgray;
            border-radius: 2em;
            height: 50px;
            min-width: 50px;
            display: inline-block;
            color: white;
        }    
}

    </style>



</head>
<body class="">



    <script>

    </script>



    <% if (wbVerified || wbDontUse) { %>


        <div id="app">


            <header>
              
            </header>
            <main>
              <nav>

                <details>
                    <summary>Facets (click to expand):</summary>
                    <div >
                        <div>
                            <input @change="filterChange" type="checkbox" v-model="filterDoesNotHaveImage" name="filterDoesNotHaveImage" id="filterDoesNotHaveImage" class="">
                            <label class="form-check-label" for="filterDoesNotHaveImage">Does NOT have image yet</label>
                        </div>
                        <hr>
                        <span style="float:right"><a href="#" v-on:click.prevent.stop="activeProjects=[]">Unselect All</a></span>
                        <p>Projects:</p>
                        <div v-for="(c,idx) in projects">                            
                            <input @change="filterChange" type="checkbox" :value="c.id" v-model="activeProjects" :name="'project_check_box_' + idx" :id="'project_check_box_' + idx" class="">
                            <label class="form-check-label" :for="'project_check_box_' + idx">{{c.label}}</label>
                        </div>

                        <hr>
                        <p>Classes:</p>
                        <div v-for="(c,idx) in classes">                            
                            <input @change="filterChange" type="checkbox" :value="c.id" v-model="activeClasses" :name="'check_box_' + idx" :id="'check_box_' + idx" class="">
                            <label class="form-check-label" :for="'check_box_' + idx">{{c.label}}</label>
                        </div>

                    </div>
                </details>
                <div class="filter-holders" style="margin-bottom: 1em;">
                      <input class="input" style="border: none; box-shadow: none;" type="text" @keyup="filterTextChangeDom($event)" placeholder="Filter...">

                </div>  



                <template v-if="!filtering">

                    <div class="list-holder" @click="loadItem(item.qid)" v-for="(item,idx) in filteredItems" :key="'item_'+idx+'_'+keyCounter">

                        <div class="list-holder-image-holder">
                            <template v-if="imageLookup[item.qid]">
                                <img :src="item.image">
                            </template> 
                            <template v-else>
                                <span class="initals">{{returnInitals(item.label)}}</span>
                            </template>


                        </div>
                        <div class="list-holder-name-holder">
                            
                            <span>{{item.label}}</span>

                        </div>

                        

                    </div>
                    <div style="font-style:oblique;">Only showing the first 100 results</div>

                </template>

                <template v-else>

                    <div style="padding: 1em; font-weight: bold; font-size: 3em;">Processing, please wait...</div>
                </template>                


              </nav>
              <article style="position: relative;">
                    <div style="position: absolute; left: 1%; font-size: 2em;">
                        
                        <template v-if="activeQid != null">
                            <span>
                                {{activeQid.label}},
                            </span>
                            <span style="text-transform: capitalize;">
                                {{activeQid.typeLabel}}
                            </span>
                            <a target="_blank" :href="'http://base.semlab.io/wiki/Item:'+activeQid.qid">{{activeQid.qid}}</a>
                        </template>


                    </div>
                <div class="tabs is-right is-boxed">
                  <ul>
                    <li :class="{'is-active': (mainDisplay==='crop') }">
                      <a @click="mainDisplay='crop'">
                        <span class="is-small"></span>
                        <span>Crop Image</span>
                      </a>
                    </li>
                    <li :class="{'is-active': (mainDisplay==='host') }">
                      <a @click="mainDisplay='host'">
                        <span class="is-small"></span>
                        <span>Host Image</span>
                      </a>
                    </li>
                    
                  </ul>
                </div>








                <template v-if="mainDisplay=='crop'">
                    

                    <div v-if="activeQid != null">

                        <div style="display:flex">
                            <div style="flex:1"><input class="input" v-model="urlToUse" placeholder="enter url to image here" type="text"></div>
                            <div style="flex:0"><button @click="startCrop" class="button">Load</button></div>
                            
                        </div>
                        
                        <div v-if="cropMade!=true">
                                

                            
                            <div ref="saveCropButton" style="display:none; margin-top:1em; margin-bottom: 1em; min-height: 1em;">
                                <button @click="sendCrop" style="float:right;"  class="button is-primary">Save Crop</button>    
                            </div>
                            
                            <div id="cropper-container">
                                
                            </div>


                        </div>
                        <div v-else>
                            
                            <div style="margin-top: 2em;" v-if="alreadyHasImageWarning" class="notification is-danger is-light">
                                Looks like this item already has an image.<br>
                                If you are meaning to replace the existing image make sure to <a target="_blank" :href="'http://base.semlab.io/wiki/Item:'+activeQid.qid">go to the item page</a> and remove the unwanted image.<br>
                                This tool does not remove or replace existing claims.<br>

                            </div>


                            <div style="margin-top: 2em;" v-if="cropResults" class="notification is-success is-light">
                               {{cropResults}}

                            </div>

                            


                            <div style="display: flex;margin-top: 2em;">
                                <div style="flex:1">Image (P3):</div>
                                <div style="flex:10">
                                    <img src="/getcrop">      
                                </div>
                            </div>



                            <div style="display: flex;">
                                <div style="flex:1">Title (P82):</div>
                                <div style="flex:10">
                                    <textarea class="textarea" v-model="P82" placeholder="Enter the title of this image, source, citations, info, etc." rows="10"></textarea>    
                                </div>
                            </div>
                            <div style="display: flex;">
                                <div style="flex:1">Ref URL (P114):</div>
                                <div style="flex:10">
                                    <input class="input" v-model="urlToUse" type="text">
                                    <div v-if="urlToUse.includes('semlab.s3.amazonaws.com/images/hosted/')" style="font-style:bold; color:red">
                                        ðŸ™…Make sure we have the rights to display the full higher resolution hosted image, if not remove the URL from the field.ðŸ™…  
                                    </div>
                                </div>
                            </div>

                            <button @click="sendIt" class="button">Upload and Create Claims</button>


                        </div>
                    </div>

                </template>
                <template v-else>

                    <template v-if="activeQid != null">

                        <p>
                            If the image you want to use as a crop is not online any where you can host it here.<br>
                            Only upload Jpeg files (.jpg) otherwise the cropping process may not work.<br><br>

                        </p>

                        <form ref='uploadForm' 
                                    id='uploadForm' 
                                    action='/upload' 
                                    method='post' 
                                    encType="multipart/form-data">


                            <div class="file has-name is-boxed" id="file-js">
                              <label class="file-label">
                                <input class="file-input" ref="fileupload" type="file" name="resume">
                                <span class="file-cta">
                                  <span class="file-icon">
                                    <i class="fas fa-upload"></i>
                                  </span>
                                  <span class="file-label">
                                    Choose a fileâ€¦
                                  </span>
                                </span>
                                <span ref="fileuploadname" class="file-name">
                                  
                                </span>
                              </label>
                            </div>

                            <button class="button" action="submit">Upload</button>

                        </form>



                        <h3 style="margin-top:3em">Recently Uploaded URLs:</h3>
                        <ol>
                            <li v-for="v of hostedList" :key="v.ETag">
                                {{'https://semlab.s3.amazonaws.com/' + v.Key}}                            
                            </li>

                        </ol>

                    </template>
                </template>







              </article>
            </main>



    	

         </div>

    <% }else{ %>


        <p>Please log in, redirecting to login...</p>
        <script type="text/javascript">window.location="/"</script>


    <% } %> 

<script >





	var app = new Vue({
	  el: '#app',
	  data: {
	       
           activeClasses:['Q1'],
           classes: [],
           projects: [],
           activeProjects: [],
           filterDoesNotHaveImage: true,
           mainDisplay: 'crop',
           hostedList: [],
           urlToUse: null,
           allItems: [],
           filteredItems: [],
           filterText: null,
           filtering: true,
           imageLookup: {},
           activeQid: null,
           cropMade: false,
           keyCounter: 0,

           P82: null,
           cropResults: false,
           alreadyHasImageWarning: false,


	  },

      watch: {
        mainDisplay: function(){


          if (this.mainDisplay==='host'){

            this.refreshHostedList();

            this.$nextTick(()=>{
                  const fileInput = document.querySelector('#file-js input[type=file]');
                  console.log(fileInput)
                  fileInput.onchange = () => {
                    if (fileInput.files.length > 0) {
                      const fileName = document.querySelector('#file-js .file-name');
                      fileName.textContent = fileInput.files[0].name;
                    }
                  }
            })
          }

        },

        activeProjects: function(){

            this.filterChange()
        },
        activeClasses: function(){
            this.filterChange()

        },
        filterDoesNotHaveImage: function(){
            this.filterChange()

        },



      },



      components: {
        

      },
      computed: {
         


      },


	  created: function(){


            fetch(`/clist`)
              .then(response => response.json())
              .then(data => {       

                this.classes = data
                

                fetch(`/projects`)
                  .then(response => response.json())
                  .then(data => {       

                    this.projects = data
                    // make the all active to start

                    this.activeProjects = data.map((p)=>{ return p.id})




                  });   




              });   





              if (window.location.href.includes('?hosted')){
                this.mainDisplay = 'host'
              }



	  },




  methods: {


        sendIt: function(qid){



            console.log(this.activeQid, this.P82, this.urlToUse)


            var xhr = new XMLHttpRequest();
            xhr.open("POST", `/savecrop`, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.onload = (response) => {
                
                const data = xhr.responseText;

          
                



                this.cropResults = data
                if (data.includes('Uploaded Image')){

                    console.log("HERE")
                    console.log(this.activeQid)
                    // loop through and update the image for this one
                    for (let i in this.filteredItems){

                        if (this.filteredItems[i].qid == this.activeQid.qid){

                            this.filteredItems[i].image = `https://semlab.s3.amazonaws.com/images/${this.activeQid.qid}.jpg`
                            this.keyCounter++
                            console.log("SET:",this.filteredItems[i])
                            this.activeQid.image = this.filteredItems[i].image
                        }
                        

                        

                    }

                }
                


                // that.$nextTick(()=>{
                //     document.getElementById('P114').value = that.urlToUse 
                // });
            }


            xhr.send(JSON.stringify({
                item: this.activeQid,
                P82: this.P82,
                P114: this.urlToUse
            }));  






        },


        loadItem: function(qid){

            this.cropResults=false
            this.P82 = null
            this.cropMade = false
            this.alreadyHasImageWarning =false
            this.activeQid = this.filteredItems.filter((f) => { return (qid === f.qid)})[0]

        },


        filterTextChangeDom : function(event){


            if (window.filterTimeout){
                window.clearTimeout(window.filterTimeout)   
                console.log('clearing old timeout')             
            }
            window.filterTimeout = window.setTimeout(()=>{
                console.log(event.target.value)

                if (event.target.value && event.target.value.trim() != ''){
                    this.filterText = event.target.value  
                }else{
                    this.filterText = null
                }
                this.filter()
                


            },250)



        },



        sendCrop: function(){

            let that = this

            window.cropper.getCroppedCanvas().toBlob((blob) => {



                var reader = new FileReader();

                reader.readAsDataURL(blob); 
                reader.onloadend = function() {
                    var base64data = reader.result;                
                    base64data = base64data.substr(base64data.indexOf(',')+1)
                    
                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", `/makecrop`, true);
                    xhr.setRequestHeader('Content-Type', 'application/json');
                    xhr.onload = () => {
                        
                        window.cropper.destroy()    
                        document.getElementById('cropper-container').innerHTML = ''
                                            
                        console.log("did it")
                        that.cropMade = true

                        fetch(`https://base.semlab.io/api.php?action=wbgetclaims&entity=${that.activeQid.qid}&property=P3&format=json&origin=*`)
                          .then(response => response.json())
                          .then((data) => {
                            
                            if (data && data.claims && data.claims.P3){
                                that.alreadyHasImageWarning=true
                            }



                          });


                        // that.$nextTick(()=>{
                        //     document.getElementById('P114').value = that.urlToUse 
                        // });
                    }


                    xhr.send(JSON.stringify({
                        crop: base64data  
                    }));  
                    

                }



                // const formData = new FormData();

                // Pass the image file name as the third parameter if necessary.
                // formData.append('croppedImage', blob/*, 'example.png' */);

                // // Use `jQuery.ajax` method for example
                // $.ajax('/path/to/upload', {
                //   method: 'POST',
                //   data: formData,
                //   processData: false,
                //   contentType: false,
                //   success() {
                //     console.log('Upload success');
                //   },
                //   error() {
                //     console.log('Upload error');
                //   },
                // });

 


                // var oReq = new XMLHttpRequest();
                // oReq.open("POST", `/makecrop`, true);
                // oReq.onload = function (oEvent) {
                //   // Uploaded.
                //   console.log('done')
                // };

                // oReq.send(blob);








            }, 'image/jpeg' );



            // let crop = window.cropper.getCropBoxData()













        },

        startCrop: function(){

            if (this.urlToUse.trim()=='' || !this.urlToUse.includes('http') ){
                alert('enter valid url')
                return
            }
            this.cropMade=false

            this.$nextTick(()=>{

                this.$refs.saveCropButton.style.display='none'

                document.getElementById('cropper-container').innerHTML = "Loading image..."

                var xhr = new XMLHttpRequest();
                xhr.open("POST", `/startcrop`, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onload = () => {
                    


                    this.$refs.saveCropButton.style.display='block'

                    document.getElementById('cropper-container').innerHTML = ""


                    let img = document.createElement('img')
                    img.setAttribute('src','/getcrop')
                    img.setAttribute('id','image-crop')
                    document.getElementById('cropper-container').appendChild(img)

                    const image = document.getElementById('image-crop');
                    const cropper = new Cropper(image, {
                      aspectRatio: 1 / 1,
                      crop(event) {
                        console.log(event.detail.x);
                        console.log(event.detail.y);
                        console.log(event.detail.width);
                        console.log(event.detail.height);
                        console.log(event.detail.rotate);
                        console.log(event.detail.scaleX);
                        console.log(event.detail.scaleY);
                      },
                    });


                    window.cropper = cropper


                }

                
                xhr.send(JSON.stringify({
                    url: this.urlToUse 
                }));   


            })

        },


        refreshHostedList: async function(){

            const response = await fetch('/hostedlist/');
            this.hostedList = await response.json();            


        },


        filterChange: async function(){


            this.filtering=true

            let clases = this.activeClasses.map((c)=>{ return `(wd:${c})`}).join(' ')
            let projects = this.activeProjects.map((c)=>{ return `(wd:${c})`}).join(' ')


            let sparql = `

            SELECT DISTINCT ?item ?itemLabel ?valueType ?image
            WHERE 
            {
              VALUES (?valueType) { ${clases} }
              VALUES (?valueProject) { ${projects}}

              ?item wdt:P1 ?valueType. 
              ?item wdt:P11 ?valueProject.
              
              OPTIONAL{
                ?item wdt:P3 ?image  
              }
                
              SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". } 
            }`


            let url = 'https://query.semlab.io/proxy/wdqs/bigdata/namespace/wdq/sparql?'
            url = url + new URLSearchParams({
                query: sparql
            })

            let results = fetch(url,{
                headers: {
                    'Accept' : 'application/json',
                    'User-Agent': 'image cropper - Semlab'                
                }
            })
                  .then(response => response.json())
                  .then((data) => {

                    this.allItems = data.results.bindings

                    this.filter()


                  })





            

        },

        returnInitals: function(fullName){

          const allNames = fullName.trim().split(' ');
          const initials = allNames.reduce((acc, curr, index) => {
            if(index === 0 || index === allNames.length - 1){
              acc = `${acc}${curr.charAt(0).toUpperCase()}`;
            }
            return acc;
          }, '');
          return initials;



        },

        filter: function(){

            this.filtering=true
            this.filteredItems = []

            let results = []


            for (let item of this.allItems){

                let i = {

                    'image' : (item.image) ? item.image.value : null,
                    'qid' : (item.item) ? item.item.value.split('/').splice(-1)[0] : null,
                    'label' : (item.itemLabel) ? item.itemLabel.value : null,
                    'type' : (item.valueType) ? item.valueType.value.split('/').splice(-1)[0] : null,


                }


                i['typeLabel'] = this.classes.filter((c) => (i.type === c.id))[0].label




                this.imageLookup[i.qid] = i.image

                // if we only care about ones with no image yet then dont do anything with the ones with image
                if (this.filterDoesNotHaveImage == true && i.image){
                    continue

                }

                if (this.filterText){
                    if (!i.label.toLocaleLowerCase().includes(this.filterText)){
                        continue
                    }
                }
                
                if (results.length>100){
                    break
                }

                results.push(i)

                console.log(i)





            }


            this.filteredItems = results
            console.log(this.filteredItems)
            this.filtering=false

        }

















   //      replaceEncodedChars: function(text){

   //          text = text.replaceAll('&#34;','"')
   //          text = text.replaceAll('&#39;',"'")



   //          return text

   //      },

   //      filterBlocks: function(filterValue){

   //          this.activeBlocks = []

   //          let blockCopy = JSON.parse(JSON.stringify( this.doc.blocks))

   //          for (let b of blockCopy){

   //              if (filterValue){

   //                  filterValue = filterValue.toLowerCase()

   //                  if (b.text){

                         
   //                       let text = b.text.toLowerCase().replace(/\n/g,' ').replace(/\s{2}/g,' ')

   //                      if (text.includes(filterValue)){

   //                          for (let w of b.words){

   //                              for (let fs of filterValue.split(' ')){
   //                                  if (w.text.toLowerCase().includes(fs)){
   //                                      w.searchHit = true
   //                                      console.log(w)
   //                                  }
   //                              }

   //                          }


   //                          this.activeBlocks.push(b)
   //                      }

   //                  }
                   

   //              }else{

   //                  this.activeBlocks.push(b)
   //              }


   //          }

   //          if (this.activeBlocks.length==0){
   //              this.emptyBlockState='No matches found in blocks.'
   //          }

   //      },

   //      buildInstaceOfColorLookup: function(){

   //          function hexToRgb(hex) {
   //            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
   //            return result ? {
   //              r: parseInt(result[1], 16),
   //              g: parseInt(result[2], 16),
   //              b: parseInt(result[3], 16)
   //            } : null;
   //          }



   //          let types = ['None']


   //          for (let e of Object.keys(this.doc.entities)){
   //              e = this.doc.entities[e]

   //              if (e.wiki && e.wiki.semlabInstanceOf){
   //                  let t = `${e.wiki.semlabInstanceOf.instanceOfLabel} (${e.wiki.semlabInstanceOf.instanceOf})`
   //                  if (types.indexOf(t)==-1){
   //                      types.push(t)
   //                  }
   //              }
   //          }


   //          var seq = palette('mpn65', types.length);

   //          console.log(types)
   //          console.log(seq)

   //          types.forEach( (value, i) => {
   //              let rgb = hexToRgb(seq[i])
   //              this.instaceOfColorLookup[value] = `rgba(${rgb.r},${rgb.g},${rgb.b},0.25)`
   //          });




   //      },

   //      publishValidateDocId: async function(){



   //          const response = await fetch('/entity/'+this.docQId);
   //          const data = await response.json();            
   //          console.log(data)
   //          if (!data){

   //              alert('Could not find that Q Number, double check and try again')

   //          }else{

   //              if (this.doc.publish){
   //                  if (!confirm('Looks like the publish process has been started, do you want to restart the process? *IF SO MAKE SURE ANY ENTITIES (Blocks, triples, etc) CREATED FROM BEFORE HAVE BEEN REMOVED*')){
   //                      return false
   //                  }
   //              }

   //              this.doc.publish = {

   //                  'docLabel': data.labels.en.value,
   //                  'stage': 'blocks',
   //                  'qid': this.docQId

   //              }

   //              this.saveDoc()
   //          }


   //      },


   //      loadEntitiesFromWikibase: async function(){

   //          console.log("-------this.doc",JSON.parse(JSON.stringify(this.doc)))

   //          toadd = []
   //          for (let qid of this.loadEntitiesInput.split('\n')){
   //              if (qid.match(/Q[0-9]+/)){
   //                  toadd.push(qid)
   //              }
   //          }

   //          const classResponse = await fetch('/clist/');
   //          const allClasses = await classResponse.json();

   //          this.$refs.loadEntitiesFromWikibaseButton.innerHTML = 'Working...'
   //          this.$refs.loadEntitiesFromWikibaseButton.disabled = true


   //          console.log(toadd)
   //          console.log(allClasses)
   //          let added = []

   //          for (let qid of toadd){
   //              console.log('doing ',qid)

   //              const response = await fetch('/entity/'+qid);
   //              const data = await response.json();

   //              if (data){

   //                  // pull out qid and label
   //                  let qid = data.id
   //                  let label = data.id
   //                  if (data.labels && data.labels.en && data.labels.en.value){
   //                      label = data.labels.en.value
   //                  }
                    

   //                  // check to make sure it doesn';t exist

   //                  let alreadyQs = []
   //                  let eCounter = -1
   //                  let pCounter = -1
   //                  for (let k in this.doc.entities){
   //                      if (this.doc.entities[k] && this.doc.entities[k].wiki && this.doc.entities[k].wiki.semlab){
   //                          alreadyQs.push(this.doc.entities[k].wiki.semlab)
   //                      }
   //                      if (this.doc.entities[k] && this.doc.entities[k].eId){
   //                          if (this.doc.entities[k].eId > eCounter ){
   //                              eCounter= this.doc.entities[k].eId
   //                          }
   //                      }
   //                      if (this.doc.entities[k] && this.doc.entities[k].pId){
   //                          if (this.doc.entities[k].pId > pCounter ){
   //                              pCounter= this.doc.entities[k].pId
   //                          }
   //                      }


   //                  }

   //                  // // get eNumber add one to use 
   //                  eCounter++
   //                  pCounter++

   //                  //make sure the eId is unique
   //                  while (eCounter in this.doc.entities){
   //                      eCounter++
   //                  }


 

   //                  if (alreadyQs.indexOf(qid)>-1){
   //                      alert(`${label} (${qid}) is already in the pallet`)
   //                      continue
   //                  }

   //                  console.log(data)
   //                  let classQid = null
   //                  if (data.claims && data.claims.P1 && data.claims.P1[0] && data.claims.P1[0].mainsnak && data.claims.P1[0].mainsnak.datavalue && data.claims.P1[0].mainsnak.datavalue.value && data.claims.P1[0].mainsnak.datavalue.value.id ){
   //                      classQid = data.claims.P1[0].mainsnak.datavalue.value.id
   //                  }

   //                  let classLabel = null
   //                  for (let aClass of allClasses){
   //                      if (aClass.id == classQid ){
   //                          classLabel = aClass.label
   //                      }
   //                  }


   //                  console.log('alreadyQs',alreadyQs,eCounter,pCounter)


   //                  // make sure that eCounter is unique


   //                  let newEnt = {
   //                      "order": 61,
   //                      "ner": false,
   //                      "eId": eCounter,
   //                      "nerName": label,
   //                      "eType": "",
   //                      "mType": "",
   //                      "text": label,
   //                      "wiki": {
   //                        "wikidata": null,
   //                        "desc": null,
   //                        "image": null,
   //                        "semlab": qid,
   //                        "semlabInstanceOf": {
   //                          "instanceOf": classQid,
   //                          "instanceOfLabel": classLabel
   //                        }
   //                      },
   //                      "mid": null,
   //                      "replacedText": label,
   //                      "contextualText": label,
   //                      "blockOccuranceCount": 0,
   //                      "blockOccurances": {
   //                      },
   //                      "blocksFoundIn": [],
   //                      "totalFoundCount": 0,
   //                      "semlabBaseSearch": [],
   //                      "isDiscarded": false,
   //                      "pId": pCounter,
   //                      "published": true
   //                    }

   //                    console.log(newEnt)

   //                  // rebuild published
   //                  this.doc.entities[eCounter] = newEnt
   //                  this.buildPublished()

   //                  added.push(`${label} (${qid}) added`)

   //              }else{
   //                  alert('Could not find Qid', qid)
   //              }
                

   //          }


   //          this.$refs.loadEntitiesFromWikibaseButton.innerHTML = 'Load'
   //          this.$refs.loadEntitiesFromWikibaseButton.disabled = false
   //          this.loadEntitiesInput = ""
            
   //          alert(added.join(',') + ' Added to the pallet.')

   //          console.log("-------this.doc",JSON.parse(JSON.stringify(this.doc)))
   //          this.buildInstaceOfColorLookup()

   //          this.keyCounter++

   //      },



   //      returnInstanceOfColor: function(e){

            
   //          let t = 'None'
   //          if (e.wiki && e.wiki.semlabInstanceOf){
   //              t = `${e.wiki.semlabInstanceOf.instanceOfLabel} (${e.wiki.semlabInstanceOf.instanceOf})`
   //          }

   //          return this.instaceOfColorLookup[t]



   //      },

   //      clearSearchBlockText: function(){

   //          this.blockSearchVal = ''
   //          this.filterBlocks('')            
   //      },


   //      refreshPlist: function(){


   //          let self = this

   //          fetch(`/plist`)
   //            .then(response => response.json())
   //            .then(data => {                
   //              self.plist = data
                
   //              console.log(data)
   //              self.possibleProperties = data.filter((f)=>{return f.type == "WikibaseItem"})
                
   //              self.possiblePropertiesLeft=[]
   //              self.possiblePropertiesRight=[]
   //              for (let p of self.possibleProperties){

   //                  if (self.possiblePropertiesLeft.length>self.possiblePropertiesRight.length){
   //                      self.possiblePropertiesRight.push(p)

   //                  }else{
   //                      self.possiblePropertiesLeft.push(p)
   //                  }


   //              }
   //              console.log(self.possiblePropertiesLeft)



   //            });   



   //      },
   //      refreshClist: function(){


   //          let self = this

   //          fetch(`/clist`)
   //            .then(response => response.json())
   //            .then(data => {                
   //              self.clist = data
                
   //            });   



   //      },

   //      filterPublishedTypes: function(event){


   //          this.publishedActiveFilterType = event.target.value



   //          this.buildPublished(this.publishedActiveFilterText,this.publishedActiveFilterType)


   //      },

   //      buildPublished: function(filter, type){

   //          console.log(filter, type)

   //          this.published = []
   //          let instanceOfAdded = {}

   //          this.publishedTypes = []

   //          this.publishedTypes.push({instanceOfLabel:'All', instanceOf:''})

   //          for (let e of Object.keys(this.doc.entities)){
   //              e = this.doc.entities[e]

   //              if (e.published){

   //                  if (e.wiki && e.wiki.semlabInstanceOf){
   //                      if (!instanceOfAdded[e.wiki.semlabInstanceOf.instanceOf]){
   //                          instanceOfAdded[e.wiki.semlabInstanceOf.instanceOf] = true
   //                          this.publishedTypes.push(e.wiki.semlabInstanceOf)
   //                      }
   //                  }



   //                  if (filter && type){
   //                      if (e.wiki && e.wiki.semlabInstanceOf){
   //                          if (e.wiki.semlabInstanceOf.instanceOf == this.publishedActiveFilterType){
   //                              if (e.nerName.toLowerCase().includes(filter.toLowerCase())){
   //                                  this.published.push(e)
   //                              }                                

   //                          }
   //                      }


   //                  }else if (filter){

   //                      if (e.nerName.toLowerCase().includes(filter.toLowerCase())){
   //                          this.published.push(e)
   //                      }

   //                  }else if (type){
   //                      if (e.wiki && e.wiki.semlabInstanceOf){
   //                          if (e.wiki.semlabInstanceOf.instanceOf == this.publishedActiveFilterType){
   //                              this.published.push(e)
   //                          }
   //                      }
   //                  }else{
   //                      this.published.push(e)
   //                  }
   //              }

                
   //          }


   //          this.published.sort((a, b) => a.nerName.localeCompare(b.nerName));
   //          console.log(this.published)

   //          this.publishedLeft=[]
   //          this.publishedRight=[]
   //          for (let p of this.published){

   //              if (this.publishedLeft.length>this.publishedRight.length){
   //                  this.publishedRight.push(p)

   //              }else{
   //                  this.publishedLeft.push(p)
   //              }


   //          }



   //      },

   //      splitWord:function(block,word){

   //          for (let b of this.doc.blocks){

   //              if (b.id === block.id){

   //                  let newWords = []

   //                  console.log(b,word)
   //                  let index = 0
   //                  for (let w of b.words){

   //                      if (w.order < word.order){
   //                          console.log('Before',w)
   //                          newWords.push(w)
   //                          index++
   //                      }else if (w.order == word.order){
   //                          console.log('its here',w)

   //                          let text = w.orginalText


   //                          let newSeq = text.split(' ')
   //                          // split it up and loop throguh the new words, add them into the words, increase index
   //                          for (let nW of newSeq){

   //                              console.log('nW ->',nW)
   //                              newWords.push({
   //                                  ner: false,
   //                                  order: index,
   //                                  orginalText: nW,
   //                                  text: nW,                                  
   //                              })
   //                              index++
   //                          }


   //                      }else if (w.order > word.order){
   //                          console.log('after',w)
   //                          newWords.push(w)
   //                          index++
   //                      }

                        
                        

   //                  }
   //                  b.words = newWords
   //                  // this.keyCounter++
   //                  this.filterBlocks()
   //                  console.log(b,word)

   //              }


   //          }




   //      },


   //      publishEntity: function(block,word){
   //          console.log('publishEntity',this.activePaintEntity)

   //          if (this.activePaintEntity != null){

   //              this.doc.blocks[block.id].words[word.order].eId = this.activePaintEntity
   //              this.doc.blocks[block.id].words[word.order].ner = true
   //              this.doc.blocks[block.id].words[word.order].nerName = this.doc.entities[this.activePaintEntity].nerName
   //              this.doc.blocks[block.id].words[word.order].contextualText = word.text

   //              this.needsSaving=true

   //              word.eId = this.activePaintEntity
   //              word.ner = true
   //              word.nerName = this.doc.entities[this.activePaintEntity].nerName
   //              word.contextualText = word.text

   //              console.log(this.doc.entities[this.activePaintEntity])

   //          }else{

   //              // it might not be an entitiy
   //              if (!word.eId){

   //                  // they hit a non-entity assigned word with da axe, break it up
   //                  if (this.removePaint){
   //                      this.splitWord(block,word)
   //                  }
   //                  return false
   //              }
   //              let data = this.gatherEntitiyToBlockInfo(word.eId)

   //              for (let d of data){
   //                  d.enabled =true
   //              }

   //              this.publishedEntityInfo = null

   //              this.publishNewEntityInfo = {

   //                     entity: this.doc.entities[word.eId],
   //                  occurrences: data


   //              }


   //              console.log('else')
   //              console.log(data)


   //          }
   //          // this.keyCounter++
   //          console.log(block,word)

   //      },




   //      toggleSidebar: function(event){


   //          if (this.showTriplesSidebar){
   //              this.showTriplesSidebar = false
   //          }else{
   //              this.showTriplesSidebar = true
   //              this.buildPublished()


   //          }

   //          event.preventDefault()


   //      },



   //      loadEntity: function(ent){

   //          this.publishNewEntityInfo = null
   //          this.publishedEntityInfo = {

   //              entity: ent,
   //              occurrences: this.gatherEntitiyToBlockInfo(ent)


   //          }


   //          return false




   //      },

   //      setActivePredicate: function(property){


   //          if (this.activeContext != null){
   //              this.activeContext.property = property
   //              this.activeContextProperty = property.label

   //              this.clearEmojiCursor()
   //              document.body.classList.add('cursor-active-object')

   //              console.log(this.activeContext)
   //          }else{

   //              // weneedto have a subject first
   //              if (this.activeSubject!=null){
   //                  this.activePredicate = property 
   //                  this.clearEmojiCursor()   
   //                  document.body.classList.add('cursor-active-object')
   //              }

   //          }

            
   //      },

   //      addToTriplePalette: function(event){


   //          console.log()
            
   //          if (event.target.value == 'none'){
   //              return false
   //          }

   //          for (let e of Object.keys(this.doc.entities)){
   //              e = this.doc.entities[e]
   //              if (e.eId == event.target.value){
   //                  this.tripleEntitiesPalette.push(e)
   //              }
   //          }            

   //          document.getElementById('triple-palette-select').value = 'none'


   //      },


   //      publishedEntityClick: function(entity, block, word){
            


   //          if (this.showTriplesSidebar){

   //              if (this.activeContext != null && this.activeContextProperty != null){
   //                  this.activeContext.entity = entity
   //                  // console.log(this.activeContext)
   //                  this.activeContextEntity = entity.nerName
   //                  // they jsut added context to a triple, 
   //                  this.blockTriples[this.activeContext.blockId][this.activeContext.index].context.push({p:this.activeContext.property,o:this.activeContext.entity})
   //                  // console.log(this.blockTriples[this.activeContext.blockId])
   //                  this.activeContext = null

   //                  this.needsSaving = true

   //                  console.log(this.blockTriples)
   //                  this.clearEmojiCursor()

   //                  return 
   //              }

   //              if (this.activeContext != null){
   //                  // if it gets here they are in active context mode, don't try to make a new triple
   //                  return
   //              }


   //              if (this.activeSubject==null){
   //                  this.activeSubject = entity

   //                  document.body.classList.add('cursor-active-predicate')


   //              }  
   //              // can't make the object via entity palette
   //              if (this.activeSubject !== null && this.activePredicate !== null && block != null){
   //                  this.activeObject = entity
   //                  if (!this.blockTriples[block.id]){
   //                      this.blockTriples[block.id] = []
   //                  }
   //                  this.blockTriples[block.id].push({s:this.activeSubject,p:this.activePredicate,o:this.activeObject,context:[]})
   //                  this.clearActiveTriple()
   //              }

   //              console.log(this.blockTriples)


   //          }else{


   //              if (entity && block && word){


   //                  if (this.removePaint){
   //                      // remove the tag

   //                      console.log(entity, block, word)
   //                      console.log(this.doc.blocks[block.id].words[word.order])
   //                      this.doc.blocks[block.id].words[word.order].eId = null

   //                      word.eId = null 

   //                      this.needsSaving=true


   //                      // kind of hack here to get the UI to update                     
   //                      block.words.push({ner: false,
   //                      order: 10000,
   //                      orginalText: "",
   //                      text: ""})
   //                      block.words.pop()

   //                      return false

   //                  }





   //                  this.stopPaint()
   //                  console.log(entity, block, word)

   //                  this.publishNewEntityInfo = null
   //                  this.publishedEntityInfo = {

   //                      entity: entity,
   //                      occurrences: this.gatherEntitiyToBlockInfo(entity)


   //                  }

   //              }




   //          }



   //      },

   //      gatherEntitiyToBlockInfo: function(entity){



   //          if (Number.isInteger(entity)){
   //              entity = {eId: entity}
   //          }
   //          console.log(entity,'<entity')

   //          let blocks = []

            
   //          for (let b of this.doc.blocks){

   //              for (let w of b.words){

   //                  if(w.eId && w.eId == entity.eId){


   //                      blocks.push({
   //                          b: b.id,
   //                          w: w.order
   //                      })

   //                  }

   //              }

   //          }
   //          console.log(blocks)
   //          return blocks


   //      },


   //      showBlockWord: function(event, block,word){

   //          console.log(document.getElementById(`b${block}-${word}`))


   //          document.getElementById(`b${block}-${word}`).scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"});

   //          document.getElementById(`b${block}-${word}`).style.transitionProperty = 'font-weight'
   //          document.getElementById(`b${block}-${word}`).style.transitionDuration = '3s'
   //          document.getElementById(`b${block}-${word}`).style.fontWeight = '900'
   //          document.getElementById(`b${block}-${word}`).style.transitionTimingFunction = 'ease-in-out'






   //          window.setTimeout(()=>{

   //              document.getElementById(`b${block}-${word}`).style.removeProperty('font-weight')
 

   //          },3000)

   //          window.setTimeout(()=>{

   //             document.getElementById(`b${block}-${word}`).style.removeProperty('transition-property')
   //             document.getElementById(`b${block}-${word}`).style.removeProperty('transition-duration')
   //             document.getElementById(`b${block}-${word}`).style.removeProperty('transition-timing-function')

                


   //          },6000)




   //          event.preventDefault()
   //          return false


   //      },


   //      saveDoc: function(){




   //          var xhr = new XMLHttpRequest();
   //          xhr.open("POST", `/document/${docId}/save`, true);
   //          xhr.setRequestHeader('Content-Type', 'application/json');
   //          xhr.onload = () => {
   //              // do something to response
   //              this.needsSaving = false
   //              this.lastSaveStamp = Math.round(new Date().getTime()/1000)
   //          }

            
   //          xhr.send(JSON.stringify({
   //              id: docId,
   //              blocks: this.doc.blocks,
   //              triples: this.blockTriples,
   //              entities: this.doc.entities,
   //              publish: this.doc.publish
   //          }));            




   //      },


   //      publishEntityWikibase: function(){


   //          this.publishNewEntityInfo.status = 'Working...'

   //          let instanceOf = document.getElementById('publishInstanceOf').value

   //          // ask to create it

   //          console.log(instanceOf)

   //          var xhr = new XMLHttpRequest();
   //          xhr.open("POST", `/publish`, true);
   //          xhr.setRequestHeader('Content-Type', 'application/json');

   //          let self = this



   //          xhr.onload = function() {
                


   //              let d = JSON.parse(this.responseText)

   //              if (d.qid){

   //                  // flip the flag in the entitiy lookup in the doc                 
   //                  self.doc.entities[self.publishNewEntityInfo.entity.eId].published = true
   //                  let instanceOf = self.clist.filter(c => c.id == d.instanceOf)

   //                  if (!self.doc.entities[self.publishNewEntityInfo.entity.eId].wiki){
   //                      self.doc.entities[self.publishNewEntityInfo.entity.eId].wiki = {}
   //                  }

   //                  console.log("instanceOf",instanceOf)
   //                  self.doc.entities[self.publishNewEntityInfo.entity.eId].wiki.semlab = d.qid
   //                  self.doc.entities[self.publishNewEntityInfo.entity.eId].wiki.semlabInstanceOf= {
   //                    "instanceOf": instanceOf[0].id,
   //                    "instanceOfLabel": instanceOf[0].label                  
   //                  }

   //                  self.buildInstaceOfColorLookup()

   //                  self.buildPublished()

   //                  self.refreshPlist()

   //                  self.refreshClist()

   //                  // loop throguh all the things that they did not want assigned to this publshed entitiy and remove the eId
   //                  let remove = self.publishNewEntityInfo.occurrences.filter(o => o.enabled==false)

   //                  for (let r of remove){
   //                      for (let b of self.doc.blocks){
   //                          if (b.id == r.b){
   //                              for (let w of b.words){
   //                                  if (w.order == r.w){                                        
   //                                      w.eId = null
   //                                  }
   //                              }
   //                          }
   //                      }


   //                  }

                    
   //                  // change the display
   //                  self.publishedEntityInfo = {

   //                      entity: self.publishNewEntityInfo.entity,
   //                      occurrences: self.gatherEntitiyToBlockInfo(self.publishNewEntityInfo.entity)


   //                  }        
   //                  self.publishNewEntityInfo=null            



   //              }else{

                    
   //                  self.publishNewEntityInfo.status = 'Error: ' + JSON.stringify(d.msg)


   //              }


                



   //          }

            
   //          xhr.send(JSON.stringify({
   //              label:  this.publishNewEntityInfo.entity.nerName,
   //              instanceOf: instanceOf
   //          }));     







   //      },



   //      togglePublishNewEntityEnabled: function(occurrence){

   //          for (let o of this.publishNewEntityInfo.occurrences){


   //              if (o.w == occurrence.w && o.b == occurrence.b){
   //                  o.enabled = false

   //              }

   //          }

   //          console.log(this.publishNewEntityInfo.occurrences)


   //      },


   //      clearEmojiCursor:function(){
   //          document.body.classList.remove('cursor-paint')
   //          document.body.classList.remove('cursor-remove-paint')
   //          document.body.classList.remove('cursor-active-predicate')
   //          document.body.classList.remove('cursor-active-object')


   //      },

   //      removeBlockTriple: function(blockId, index, event){

   //          this.blockTriples[blockId].splice(index, 1)
   //          event.target.parentElement.style.display='none'
   //          this.needsSaving=true
   //      },

   //      addContext: function(blockId, index){

   //          this.activeContext = {blockId:blockId,index:index}
   //          document.body.classList.add('cursor-active-predicate')
   //          console.log(this.activeContext)
   //      },

   //      clearActiveTriple:function(){
   //          this.activeSubject=null
   //          this.activePredicate=null
   //          this.activeObject=null
   //          this.clearEmojiCursor()
   //      },


   //      clearActiveContext:function(){


   //          this.activeContext = null
   //          this.activeContextEntity = null
   //          this.activeContextProperty = null
   //          this.clearEmojiCursor()
   //      },


   //      startPaint: function(entity){

   //          document.body.classList.add('cursor-paint')
            
   //          this.publishedEntityInfo = null
   //          this.removePaint = false

   //          console.log(this.activePaintEntity, this.activePaintEntity)

   //          if (this.activePaintEntity !== null && this.activePaintEntity == entity.eId){
   //              this.stopPaint()
   //              return 
   //          }

   //          this.activePaintEntity = entity.eId
   //          this.activePaintEntityColor = this.returnInstanceOfColor(entity)


   //      },

   //      stopPaint: function(){

   //          this.clearEmojiCursor()
   //          this.publishedEntityInfo = null
   //          this.removePaint = false
   //          this.activePaintEntity = null
   //          this.activePaintEntityColor = null

   //      },

   //      toggleRemovePaint: function(){
   //          this.clearEmojiCursor()

   //          this.publishedEntityInfo = null
   //          this.activePaintEntity = null

   //          if (this.removePaint){
   //              this.removePaint = false

                
   //              this.clearEmojiCursor()


   //          }else{
   //              this.removePaint = true
   //              document.body.classList.add('cursor-remove-paint')
   //          }


   //      }


	  }
	})


</script>

</body>




</html>